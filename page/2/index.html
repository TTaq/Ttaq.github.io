<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Hexo</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%AB%E8%82%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/10/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%AB%E8%82%A1/" class="post-title-link" itemprop="url">操作系统八股</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-10-04 15:36:40" itemprop="dateCreated datePublished" datetime="2024-10-04T15:36:40+08:00">2024-10-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-10-10 17:58:18" itemprop="dateModified" datetime="2024-10-10T17:58:18+08:00">2024-10-10</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h1><h2 id="什么是用户态和内核态"><a href="#什么是用户态和内核态" class="headerlink" title="什么是用户态和内核态"></a>什么是用户态和内核态</h2><p>内存分为内核空间和用户空间，用于保护系统稳定性和安全性<br>内核空间:是操作内核代码及其运行时数据结构所在的内存区域，拥有对系统所有资源的访问权限，如进程管理，内存管理，文件系统，网络堆栈等<br>用户空间:是操作系统为用户程序(如用户运行的进程)分配的内存区域，用户空间中的进程不能直接访问硬件或内核数据结构，只能通过系统调用与内核通信</p>
<h2 id="用户态和内核态是如何切换的"><a href="#用户态和内核态是如何切换的" class="headerlink" title="用户态和内核态是如何切换的"></a>用户态和内核态是如何切换的</h2><p>当应用程序执行系统调用时，CPU将从用户态切换到内核态，进入内核空间执行相应的内核代码，然后再切换回用户态<br>系统调用是应用程序请求操作系统内核提供服务的接口，如文件操作(open,read,write)，进程控制(fork,exec)，内存管理(mmap)等</p>
<h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><h2 id="并发和并行的区别"><a href="#并发和并行的区别" class="headerlink" title="并发和并行的区别"></a>并发和并行的区别</h2><p>并发是指在一段时间内，多个任务都会被处理，但是在某一时刻，只有一个任务执行。单核处理器做到的并发是通过利用时间片的轮转，因为切换速度快，所以宏观上表现为一段时间内同时运行多个程序<br>并行是指在同一时刻，有多个任务执行。不同的程序被放在不同的处理器上执行，这个是物理上的多个进程同时进行</p>
<h2 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a>进程上下文切换</h2><p>上下文切换是操作系统在多任务处理环境中，将CPU从一个进程切换到另一个进程的过程。通过让多个进程共享CPU资源，使系统能够并发执行多个任务<br>切换步骤：1.保存当前进程的上下文，操作系统保存当前进程的CPU寄存器，程序状态等关键信息<br>2.选择下一个进程：调度程序选择下一个要执行的进程<br>3.恢复上一个进程的上下文<br>4.切换到下一个进程</p>
<h2 id="进程有哪些状态"><a href="#进程有哪些状态" class="headerlink" title="进程有哪些状态"></a>进程有哪些状态</h2><p>运行状态:该时刻进程占用CPU<br>就绪状态:可运行，但是由于其他进程处于运行状态而暂时停止运行(等待CPU)<br>阻塞状态:不可运行，该进程等待某一事件的发生而暂时停止运行，这时即使拥有CPU控制权，也无法运行<br>创建状态:进程正在被创建的状态<br>结束状态:进程正在从系统中消失的状态</p>
<h2 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h2><p>僵尸进程是已完成且处于终止状态，但是在进程表中仍然存在的进程<br>一般发生有父子关系的进程中，一个子进程的进程描述符退出时不会释放，只有当父进程调用wait()或waitpid()获取子进程信息后才会释放，如果子进程退出后，而父进程并没有调用wait()或waitpid()，那么子进程的进程描述符仍然保存在系统中</p>
<h2 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h2><p>一个父进程退出，他的一个或多个子进程还在运行，那么这些子进程就会成为孤儿进程。孤儿进程将被init进程(进程ID为1)收养，并有init进程对它们完成状态收集工作</p>
<h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><p>先进先出FIFO:按照请求CPU的顺序进行调度，易于实现，但是可能会出现较短的进程等待较长的进程执行完成，产生饥饿现象<br>短作业优先:选择预计时间最短的进程优先执行，减少了平均等待时间和响应时间，缺点是很难准确预估进程的执行时间，且可能因为短作业一直执行，导致长作业持续推迟<br>优先级调度:每个进程分配一个优先级，CPU首先分配给优先级最高的进程。优先级可以是抢占式的或非抢占式的，在非抢占式优先级调度中，进程一旦开始执行将一直运行到完成。在抢占式的优先级调度中，更高优先级的进程可以中断正在执行的进程<br>时间片轮转:为每个进程分配一个固定的时间段，进程可以在时间片内运行。可以保证所有的进程得到公平的CPU时间，适用于共享系统<br>最短剩余时间优先:短作业优先的改进形式，它是抢占式的。可以最小化平均等待时间<br>多级反馈队列：时间片轮转调度算法和优先级调度算法的结合</p>
<h2 id="进程间通信方式"><a href="#进程间通信方式" class="headerlink" title="进程间通信方式"></a>进程间通信方式</h2><p>进程间通信(IPC)方式有：管道，信号，消息队列，共享内存，信号量和套接字</p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>可以理解成不同进程之间的传话筒。进程间的管道是内核中的一串缓存，从管道的一端写入数据，另一端读取。数据只能单向移动，遵循FIFO规则<br>匿名管道：允许具有亲缘关系的进程进行通信<br>命名管道：允许无亲缘关系的进程通信，通过在文件系统中创建一个特殊类型的文件来实现<br>缺点：管道的效率低，不适合频繁的交换数据</p>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>用于通知接收进程某件事情发生了，主要用于处理异步事件<br>比如 kill -9 1050 就表示给PID为1050的进程发送SIGKIL信号<br>常用信号：SIGHUP当我们退出终端时，由该终端启用的所有进程都会接受到这个信号，默认动作为终止进程<br>SIGINT：程序终止信号，按ctrl+c时发出<br>SIGQUIT：和SIGINT类似，按ctrl+\发出。他会产生核心转储文件，将内存映像和程序运行时的状态记录下来<br>SIGKIL：强制杀死进程，本信号不能被阻塞和忽略<br>SIGTERM:与SIGKIL不同的是该信号可以被阻塞和处理，通常用于要求程序自己正常退出</p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列是保存在内核中的消息链表，按照消息的类型进行消息传递，具有较高的可靠性和稳定性<br>缺点：消息体有最大长度限制，不适合较大的数据传输。存在用户态和内核态之间的拷贝开销</p>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>允许两个或多个进程共享一个给定的内存区，一个进程写入东西，其他进程可以马上看到<br>共享内存是最快的进程间通信方式，它是针对其他进程间通信方式效率低而设计的<br>缺点：当多进程竞争同一个共享资源时，会造成数据错乱的问题</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>本质上是一个计数器，用来控制对共享资源的访问数量<br>两种原子操作：1.P操作(wait，减操作),当进程希望获取资源时，他会执行P操作，如果信号量的值大于0，表示有资源可用，信号量的值减1，进程继续执行。如果信号量的值为0，表示没有可用资源，进程进入等待状态，直到信号量的值变为大于0<br>2.V操作(signal，加操作)：当进程释放资源时，他会执行V操作，信号量值加1。如果有其他进程因为等待该资源而阻塞，则会唤醒其中一个进程</p>
<h3 id="套接字socket"><a href="#套接字socket" class="headerlink" title="套接字socket"></a>套接字socket</h3><p>提供网络通信的端点，可以让不同机器上运行的进程之间双向通信</p>
<h2 id="进程和线程的联系和区别"><a href="#进程和线程的联系和区别" class="headerlink" title="进程和线程的联系和区别"></a>进程和线程的联系和区别</h2><p>进程是一个正在运行的程序的实例，每个进程都有自己的地址空间，全局变量，堆栈和文件描述符等资源<br>线程是进程中的一个执行单元，一个进程可以包含多个线程，他们共享进程中的地址空间和资源<br>每个进程在独立的空间运行，不会直接影响其他进程。线程共享同一个进程的内存空间，全局变量和文件描述符<br>进程切换需要保存和恢复大量的上下文信息，代价较高。线程的切换较为轻量，因为线程共享进程的地址空间，只需要保存和恢复线程的私有数据<br>线程的生命周期由进程控制，当进程终止时，该进程的所有线程也会终止</p>
<h2 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h2><p>当两个线程不属于同一个进程，切换的过程与进程上下文切换一样<br>当两个线程属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不变，只需要切换线程的私有数据，寄存器等不共享的资源</p>
<h2 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h2><p>内核态线程实现：在内核空间实现的线程，由内核直接管理线程<br>用户态线程实现：在用户空间实现线程，不需要内核的参与，内核对线程无感知<br>混合线程实现：用户态的执行系统负责进程内部线程在非阻塞时的切换。内核态的操作系统负责阻塞线程的切换。我们同时实现内核态和用户态的线程管理，其中内核态线程数量较少，用户态线程数量较多，每个内核态线程都可以服务一个或多个用户态线程</p>
<h2 id="线程间如何同步"><a href="#线程间如何同步" class="headerlink" title="线程间如何同步"></a>线程间如何同步</h2><p>同步解决的多线程操作共享资源问题，目的是不管线程之间如何穿插，最后的结果都是正确的<br>临界区：对共享资源访问的程序片段称为临界区，我们希望这段代码是互斥的，保证在某一时刻只能被一个线程执行，一个线程在临界区时，其他线程应该被阻止进入临界区<br>临界区不仅针对于线程，同样针对进程</p>
<h3 id="临界区同步实现方式"><a href="#临界区同步实现方式" class="headerlink" title="临界区同步实现方式"></a>临界区同步实现方式</h3><h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p>使用加锁操作和解锁操作可以解决并发线程&#x2F;进程互斥的问题<br>任何想要进入临界区的线程，都必须先执行加锁的操作，若加锁操作顺利通过，则线程可以进入临界区。在完成对临界资源的访问后再进行解锁操作以释放临界资源<br>加锁和解锁锁住的可以是临界区对象，也可以是一个简单的互斥量<br>根据锁的实现不同，可以分为忙等待锁和无忙等待锁<br>忙等待锁：加锁失败的线程会不断尝试重新获取锁，也成为自旋锁，它会一直占用CPU<br>无忙等待锁：加锁失败的线程进入阻塞状态，放弃CPU，等待被调度</p>
<h4 id="信号量-1"><a href="#信号量-1" class="headerlink" title="信号量"></a>信号量</h4><p>信号量是操作系统中提供的一种协调共享资源访问的方法<br>通常信号量表示资源的数量，对应的量为一个整型sem变量<br>两个原子操作系统调用函数来控制信号量<br>P操作：将sem减1，如果相减后，sem&lt;0则进程&#x2F;线程进入阻塞等待，否则继续，表明P操作可能会阻塞<br>V操作：将sem加1，相加后，如果sem&lt;&#x3D;0，唤醒一个等待中的进程&#x2F;线程，表明V操作不会阻塞<br>P操作是在进入临界区之前，V操作是在离开临界区之后，这两个操作必须成对出现</p>
<h2 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h2><p>在两个或多个线程里，如果每个线程持有某种资源，而又等待其他线程释放它现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组线程产生了死锁<br>就是两个或多个线程无限期阻塞，相互等待的一种状态</p>
<h2 id="死锁产生条件"><a href="#死锁产生条件" class="headerlink" title="死锁产生条件"></a>死锁产生条件</h2><p>1.互斥<br>2.持有并等待<br>3.不可抢占<br>4.循环等待</p>
<h2 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h2><p>破坏死锁产生条件中的其中一个<br>1.消除请求并等待条件，一个线程一次性请求其所需要的所有资源<br>2.消除不可抢占条件，占用部分资源的线程进一步申请资源的时候，如果申请不到，可以主动释放它占用的资源<br>3.消除循环等待条件，可以靠按序申请资源来预防，指资源是有线性顺序的，申请资源的时候先申请序号小的，再申请序号大的</p>
<h2 id="活锁和饥饿锁"><a href="#活锁和饥饿锁" class="headerlink" title="活锁和饥饿锁"></a>活锁和饥饿锁</h2><p>活锁：在活锁状态下，处于活锁线程组里的线程状态可以改变，但是整个活线程组的线程无法推进<br>饥饿锁：饥饿指的是资源饥饿，某个线程一直等不到它需要的资源，从而无法向前推进</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/02/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/10/02/%E8%AE%A1%E7%BD%91%E5%85%AB%E8%82%A1/" class="post-title-link" itemprop="url">计网八股</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-10-02 21:29:13" itemprop="dateCreated datePublished" datetime="2024-10-02T21:29:13+08:00">2024-10-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-10-09 16:13:51" itemprop="dateModified" datetime="2024-10-09T16:13:51+08:00">2024-10-09</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="网络协议层次"><a href="#网络协议层次" class="headerlink" title="网络协议层次"></a>网络协议层次</h1><p>TCP&#x2F;IP四层模式 应用层、传输层、网络层、网络接口层<br>TCP&#x2F;IP五层模型 应用层、传输层、网络层、数据链路层、物理层<br>OSI七层模型    应用层 表示层 会话层 传输层 网络层 数据链路层 物理层<br>TCP&#x2F;IP层次对应的协议<br>应用层:HTTP,DNS(域名解析),FTP(文件传输协议)<br>传输层:UDP,TCP<br>网络层:IP(网际协议),ICMP(互联网控制报文协议),IGMP(互联网组管理协议),RIP</p>
<h1 id="TCP数据段包括哪些内容"><a href="#TCP数据段包括哪些内容" class="headerlink" title="TCP数据段包括哪些内容"></a>TCP数据段包括哪些内容</h1><p>源端口、目的端口、序列号、确认号、ACK、SYN、FIN等、校验和、窗口大小、可选项</p>
<h1 id="TCP如何拆包、组装包-UDP需要吗"><a href="#TCP如何拆包、组装包-UDP需要吗" class="headerlink" title="TCP如何拆包、组装包?UDP需要吗?"></a>TCP如何拆包、组装包?UDP需要吗?</h1><p>拆包、粘包原因:TCP是面向字节流，字节流没有明确分界线，TCP底层并不了解数据具体含义，只会根据TCP缓冲区情况进行包划分，因此会出现拆包，粘包现象<br>  1.拆包:一个包过大，超过缓冲区大小，拆分发送<br>  2.粘包:两个包过小，间隔时间短,合成一个包<br>  3.拆包&amp;粘包:Packet1过大，被拆包，而拆出去的部分又与Packet2粘包<br>UDP面向消息,没有拆包和粘包.因为UDP没有保护边界(每个UDP都有消息头,应用程序必须以消息为单位提取数据)</p>
<h1 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h1><p>UDP:对网络通讯质量要求不高，要求网络通讯速度要快的场景<br>特点:1.无连接<br>2.尽最大努力交付，不保证可靠交付，不使用拥塞控制<br>3.面向报文，适合多媒体通信<br>4.支持一对一，一对多，多对一，多对多的交互通信<br>5.首部开销小，8个字节<br>场景：直播，语音<br>TCP:当对网络通讯质量有要求时，比如HTTP，HTTPS，FTP等文件传输协议，POP3，SMTP等邮件传输的协议<br>特点：1.面向连接的<br>2.每一条TCP有且只有两个端点，是一对一关系<br>3.提供可靠交付<br>4.全双工通信，即可传输有可接收<br>5.面向字节流<br>场景：游戏，邮件，信息</p>
<h1 id="TCP为什么可靠"><a href="#TCP为什么可靠" class="headerlink" title="TCP为什么可靠"></a>TCP为什么可靠</h1><p>乱序重排、应答确认<br>报文重传<br>拥塞控制(接收方受不了)<br>流量控制(网路受不了)</p>
<h2 id="乱序重排、应答确认"><a href="#乱序重排、应答确认" class="headerlink" title="乱序重排、应答确认"></a>乱序重排、应答确认</h2><p>都跟序号有关，由于网络或多线程等因素，接收方收到的数据段很可能是乱序的，不过，因为每个TCP封装都有序号，接收方重组起来非常容易<br>发送方发送多段报文后，共n个字节，接收方只需要向发送方发一个确认号为n+1的报文即可</p>
<h2 id="报文重传"><a href="#报文重传" class="headerlink" title="报文重传"></a>报文重传</h2><h3 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h3><p>发送方收不到确认的时候用。网速不一样导致传输时每个报文的延时也不一样，TCP会根据报文的往返时间(RTT)自动调整超时重传时间(RTO)。发送方每发一个报文，都会开始计时，如果时间超过了RTO还没收到这个报文段的确认，就会重传该报文</p>
<h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><p>发送的数据在路上丢失的时候用。接收方收到序号为n的报文，回复确认号为n+1的报文，但是却收到了比n+1大的报文段，于是连续发出了确认号n+1的报文。如果发送方连续三次收到重复的信号，立即重发该报文段，而不管是否超时</p>
<h2 id="流量控制-滑动窗口解决"><a href="#流量控制-滑动窗口解决" class="headerlink" title="流量控制(滑动窗口解决)"></a>流量控制(滑动窗口解决)</h2><p>应用程序无论是发送数据还是接收数据，都会将数据放入缓冲区，再从缓冲区读取数据。<br>当接收方应用程序处理速度比发送方的发送速度慢，就会造成接收区缓冲区的溢出<br>TCP在三次握手的时候，会协商双方缓冲区window的大小。如果接收方的处理速度慢，接收方就会通过window告诉发送方，实现动态调整，避免溢出</p>
<h3 id="滑动窗口控制流量的基本原理"><a href="#滑动窗口控制流量的基本原理" class="headerlink" title="滑动窗口控制流量的基本原理"></a>滑动窗口控制流量的基本原理</h3><p>当前的窗口大小为m，假定当前发送方已经发送到第x个字节，接收方期待接收到的下一个字节的序号为n，那么还可以发送的字节数就是y&#x3D;m-(x-n)</p>
<h2 id="拥塞控制-拥塞控制"><a href="#拥塞控制-拥塞控制" class="headerlink" title="拥塞控制(拥塞控制)"></a>拥塞控制(拥塞控制)</h2><p>慢开始，拥塞避免，快速重传，快速恢复<br>swnd发送窗口 &#x3D; min(cwnd拥塞窗口,rwnd接收窗口)</p>
<h3 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h3><p>开始时cwnd拥塞窗口是以指数型增长的，一直到cwnd等于ssthresh阈值时启动拥塞控制算法</p>
<h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h3><p>进入拥塞避免阶段，cwnd每次增加1。当出现报文丢失时，丢失的报文重传计时器超时后会被判断出现拥塞，此时需要更改cwnd和ssthresh<br>出现拥塞:<br>1.ssthresh更新为出现拥塞时cwnd数值的一半<br>2.cwnd赋值为1<br>3.重新执行慢开始算法<br>不足之处：当个别报文在网络中丢失，实际网络并未发生拥塞，这将导致发送端超时重传，并误以为网络发送拥塞。用于每次发生拥塞都会导致cwnd设置为1，这严重降低了传输效率</p>
<h3 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h3><p>使发送方尽快进行重传，而不是等超时重传计时器超时再重传<br>1.接收方不要等待自己发送数据才进行捎带确认，而是立即发送确认<br>2.即使收到了失序的报文段也需要立即对已收到的报文段发送重复确认<br>3.发送方一旦发送3个连续的重复确认，就将相应的报文段立即重传，而不是等待该报文段的超时重传计时器超时再重传<br>4.对于个别丢失的报文段，发送方不会超时重传，就不会误认为发生了拥塞控制。<br>5.使用快重传使整个网络的吞吐量提高约20%</p>
<h3 id="快恢复-区别丢失个别报文还是网络拥塞，防止误判"><a href="#快恢复-区别丢失个别报文还是网络拥塞，防止误判" class="headerlink" title="快恢复(区别丢失个别报文还是网络拥塞，防止误判)"></a>快恢复(区别丢失个别报文还是网络拥塞，防止误判)</h3><p>发送端连续接收到三个连续的重复确认报文后确认只是丢失了个别的报文(确认报文可以传回，网络没有拥塞)，此时不需要开启慢开始算法。<br>此时将ssthresh和cwnd赋值为此时的cwnd的一半，然后执行避免拥塞算法</p>
<h1 id="在浏览器中输入URL后，执行的全过程-一次完整的http请求过程"><a href="#在浏览器中输入URL后，执行的全过程-一次完整的http请求过程" class="headerlink" title="在浏览器中输入URL后，执行的全过程(一次完整的http请求过程)"></a>在浏览器中输入URL后，执行的全过程(一次完整的http请求过程)</h1><h2 id="1-域名解析"><a href="#1-域名解析" class="headerlink" title="1.域名解析"></a>1.域名解析</h2><p>浏览器搜索自己的DNS缓存(维护一张域名与IP地址的对应表)<br>若没有，则搜索操作系统中的DNS缓存<br>若没有，则搜索操作系统中的hosts文件<br>若没有，则操作系统将域名发送到本地域名服务器–(递归查询方式)，本地域名服务器查询自己的DNS缓存，查找成功则返回结果，<br>否则，本地域名服务器向根服务器发起请求，此外，根域名服务器返回com域的顶级域名服务器地址,本地域名服务器向com域的顶级域名服务器发起请求，返回baidu.com权限域名服务器，本地域名服务器向baidu.com权限域名服务器发起请求，得到<a target="_blank" rel="noopener" href="http://www.baidu.com的ip地址,本地域名服务器将得到的ip地址返回给操作系统,同时将自己也将ip地址缓存起来/">www.baidu.com的IP地址,本地域名服务器将得到的IP地址返回给操作系统，同时将自己也将IP地址缓存起来</a></p>
<h2 id="2-发起TCP的三次握手"><a href="#2-发起TCP的三次握手" class="headerlink" title="2.发起TCP的三次握手"></a>2.发起TCP的三次握手</h2><p>第一次握手:建立连接时，客户端发送syn包(syn&#x3D;j)到服务器，并进入SYN_SEND状态，等待服务器确认<br>第二次握手:服务器收到syn包，必须确认客户的SYN(ack&#x3D;j+1),同时自己也发送一个SYN包(syn&#x3D;k)，即SYN+ACK包，此时服务器进入SYN_RECV状态<br>第三次握手:客户端收到服务器的SYN+ACK包，向服务器发送确认包(ack&#x3D;k+1),此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成第三次握手(防止已经失效的连接请求报文又突然传到了服务器，因而产生错误连接，导致服务器资源白白浪费)</p>
<h2 id="3-建立TCP连接后发起http请求-http浏览器缓存机制"><a href="#3-建立TCP连接后发起http请求-http浏览器缓存机制" class="headerlink" title="3.建立TCP连接后发起http请求(http浏览器缓存机制)"></a>3.建立TCP连接后发起http请求(http浏览器缓存机制)</h2><h2 id="4-服务器响应http请求"><a href="#4-服务器响应http请求" class="headerlink" title="4.服务器响应http请求"></a>4.服务器响应http请求</h2><p>负载均衡，网站可能会有负载均衡设备来平均分配所有用户的请求，即对工作任务进行平衡，分摊到多个操作单元上执行，如图片服务器，应用服务器等<br>请求处理阅读请求以及他的参数和cookies</p>
<h2 id="5-浏览器解析html代码，并请求html代码中的资源-js-css-图片等"><a href="#5-浏览器解析html代码，并请求html代码中的资源-js-css-图片等" class="headerlink" title="5.浏览器解析html代码，并请求html代码中的资源(js,css,图片等)"></a>5.浏览器解析html代码，并请求html代码中的资源(js,css,图片等)</h2><p>查看是否为长连接，来觉得是否需要断开tcp连接</p>
<h2 id="6-断开TCP连接-四次挥手"><a href="#6-断开TCP连接-四次挥手" class="headerlink" title="6.断开TCP连接(四次挥手)"></a>6.断开TCP连接(四次挥手)</h2><p>1.客户端向服务器发送FIN报文，表示不再发送数据，进入FIN-WAIT-1状态<br>2.服务器接收到FIN报文，发送ACK报文，进行CLOSE-WAIT状态<br>3.服务器不再发送数据时，发送FIN报文给客户端，进入LAST-ACK状态<br>4.客户端接收到服务器的FIN报文后，发送ACK报文作为最后确认，进入TIME-WAIT状态，等待一段时间(2MSL)后关闭连接<br>MSL:报文段最大生存时间，它是任何报文段被丢弃在网络内的最长时间<br>为什么是2MSL后关闭连接：<br>1.保证TCP协议的全双工连接能够可靠关闭(第四次挥手有可能会丢失，服务器收不到需要重新请求，若客户端不等待2MSL，则导致客户端收不到服务器的重新请求，处于死锁)<br>2.保证这次连接的重复数据段从网络中消失<br>第二次挥手和第三次挥手不能合并的原因:服务器数据还未传输完成，发送ACK后，等到数据传输完成，然后进行第三次挥手<br>为什么还要挥手第四次：因为第三次挥手有可能丢失，客户端就会一直等待，所以需要第四次挥手确认</p>
<h2 id="7-浏览器对页面进行渲染呈现给用户"><a href="#7-浏览器对页面进行渲染呈现给用户" class="headerlink" title="7.浏览器对页面进行渲染呈现给用户"></a>7.浏览器对页面进行渲染呈现给用户</h2><h1 id="HTTP报文段"><a href="#HTTP报文段" class="headerlink" title="HTTP报文段"></a>HTTP报文段</h1><p>请求报文:请求行(请求方法，URL，协议版本)、请求头、空行、实体体<br>  常见头:Host,User-Agent,Connection,Accept-Charset,Accept-Encoding,Accept-Language<br>响应报文:状态行(协议版本，状态码，状态码描述)、响应头、空行、实体体<br>  常见头:Date,Server,Connection,Cache-Control,Content-Type,Content-Length,Content-Charset,Content-Encoding,Content-Language</p>
<h1 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h1><p>HTTP：<br>1.HTTP协议目的是规定客户端和服务端数据传输的格式和数据交互行为，并不负责数据传输的细节，它是基于TCP实现。现在使用的版本中默认是持久连接的，也就是多次HTTP请求使用一个TCP连接<br>2.HTTP协议是无状态的，每次HTTP请求都是独立的，任何两个请求之间没有什么必然的联系，但是实际应用中引入了cookie和session机制来关联请求<br>3.方法:get,post,delete,put…</p>
<p>区别：1.HTTPS请求协议需要CA(证书颁发机构)申请证书<br>2.HTTP是超文本传输协议，信息是明文传输，HTTPS则是具有安全性的TLS加密传输协议<br>3.HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80后者是443<br>4.HTTP的连接很简单，是无状态的。HTTPS协议是由TLS+HTTP协议构建的可进行加密传输，身份认证的网络协议，比HTTP协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息)</p>
<h2 id="HTTPS详解"><a href="#HTTPS详解" class="headerlink" title="HTTPS详解"></a>HTTPS详解</h2><p>1.用户在浏览器发送HTTPS请求，默认使用443端口进行连接<br>2.HTTPS使用一套CA数字证书，证书内会附带一个pub公钥，而与之对应的私钥private保留在服务端不公开<br>3.服务端收到请求，返回配置好的包含公钥pub的证书给客户端<br>4.客户端收到证书，校验合法性，主要包含是否在有效期内，证书的域名与请求的域名是否匹配，上一级证书是否有效(递归判断，直到判断到系统内置或浏览器配置好的根证书),如果不通过，则显示HTTPS警告信息，如果通过则继续<br>5.客户端生成一个用于对称加密的随机key，并用证书的公钥pub进行加密，发送给服务端<br>6.服务器收到随机key的密文，使用与公钥key配对的私钥private进行解密，得到客户端真正想要发送的随机key<br>7.服务端使用客户端发送来的随机key对要传输的HTTP数据进行加密，将密文返回到客户端<br>8.客户端使用随机key对称解密密文，得到HTTP数据明文<br>9.后续HTTP请求使用之前交换好的随机key进行对称加密和解密</p>
<h1 id="HTTP连接和socket连接的区别"><a href="#HTTP连接和socket连接的区别" class="headerlink" title="HTTP连接和socket连接的区别"></a>HTTP连接和socket连接的区别</h1><p>HTTP链接是以HTTP协议为通信协议的TCP连接<br>HTTP协议是应用层的，而socket是对TCP&#x2F;IP协议的封装和应用，是一个API</p>
<h1 id="HTTP-Restful是什么"><a href="#HTTP-Restful是什么" class="headerlink" title="HTTP Restful是什么"></a>HTTP Restful是什么</h1><p>定义:Web Service架构。通过语义化方式请求资源URL，解决URL膨胀问题<br>作用:通过URL知道要什么资源，通过HTTP method知道要干什么。通过状态码知道结果如何<br>优点:风格统一、面向资源、充分利用HTTP本身语义</p>
<h1 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h1><p>1** - 信息，服务器收到请求，需要请求者继续执行操作<br>2** - 成功，操作被成功接收并处理<br>3** - 重定向，需要进一步的操作以完成请求<br>4** - 客户端错误，请求包含语法错误或无法完成请求<br>5** - 服务器错误，服务器在处理请求的过程中发生了错误</p>
<h1 id="get-post-put区别"><a href="#get-post-put区别" class="headerlink" title="get,post,put区别"></a>get,post,put区别</h1><p>1.get用于请求服务器返回资源，post一般用于表单的提交<br>2.get方法请求参数会拼接在URL上不安全，post方法的请求参数放在请求体中<br>3.get请求有URL长度限制，post对长度无要求<br>4.get请求会被浏览器主动cache，post不会，除非手动设置<br>5.get请求在浏览器反复的回退&#x2F;前进操作是无害的，而post操作则会再次提交表单请求<br>6.get请求在发送过程中会产生一个TCP数据包，post会发送两个TCP数据包。对于get请求，浏览器会把http header和data一并发送出去，服务器响应200，而对于post，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok<br>7.put是向服务器端发送数据，修改数据的内容，但不会增加数据的种类<br>8.post则会改变数据种类等资源，会创建新的内容</p>
<h1 id="cookie和session，token的区别"><a href="#cookie和session，token的区别" class="headerlink" title="cookie和session，token的区别"></a>cookie和session，token的区别</h1><p>Cookie存放在客户端浏览器中 Session存放在服务器中<br>cookie的大小受限制，单个cookie保存的数据不能超过4K。很多浏览器都限制一个站点最多保存20个cookie。session的大小一般不受限制<br>token代表一小段字符串<br>工作原理：服务器在第一次收到请求时，开辟一块Session空间，同时生成了一个session id，并通过响应头的Set-Cookie:”JESSIONID&#x3D;XXX”命令，向客户端发送要求设置cookie的响应，客户端收到响应后，在本机客户端设置了一个JESSIONID&#x3D;XXX的cookie信息，该cookie的过期时间为浏览器结束。接下来客户端每次向同一个网站发送请求时，请求头都会带上该cookie信息(包含sessionid)。然后，服务器通过读取请求头中的cookie信息，获取名称为JSESSIONID的值，得到此次请求的session id.在cookie中加入sessionId</p>
<h1 id="IP地址的划分"><a href="#IP地址的划分" class="headerlink" title="IP地址的划分"></a>IP地址的划分</h1><p>A类:大型网络,0.0.0.127-127.255.255.255(前四位0111),掩码:255.0.0.0<br>B类:中型网络,128.0.0.0-191.255.255.255(1011),掩码:255.255.0.0<br>C类:小型网络,192.0.0.0-223.255.255.255(1101),掩码:255.255.255.0<br>D类:广播地址(1110)<br>E类:保留以后用(1111)    </p>
<h1 id="两台机器之间的通讯过程"><a href="#两台机器之间的通讯过程" class="headerlink" title="两台机器之间的通讯过程"></a>两台机器之间的通讯过程</h1><p>在同一网段内:PC1进行ARP广播，得到PC2的MAC地址，然后PC1封装数据-&gt;交换机-&gt;PC2<br>不在同一网段内:PC1进行ARP广播，得到网管的MAC地址，然后PC1封装数据-&gt;交换机-&gt;路由-&gt;交换机-&gt;PC2</p>
<h1 id="ARP协议-地址解析协议"><a href="#ARP协议-地址解析协议" class="headerlink" title="ARP协议(地址解析协议)"></a>ARP协议(地址解析协议)</h1><p>作用:将目标IP地址转换为MAC地址<br>原因:在以太网环境中，数据的传输依靠MAC地址而不是IP地址<br>工作流程:假设主机A和B在同一个网段，主机A要向B发送消息，具体的地址解析如下<br>(1)主机A查看自己的ARP表中，如果在表中找到主机B的MAC地址，则用MAC地址对IP数据包进行帧封装，并将数据包发送给主机B<br>(2)主机A的ARP表中找不到主机B的MAC地址，则通过广播的方式发送一个ARP请求报文(包含自身的IP地址，MAC地址，目标IP地址，全为0的MAC地址),在该网段上的所有主机都可以收到该报文，但是只有IP地址匹配的主机才会对该请求进行处理，首先将ARP请求报文中发送段的IP地址和MAC地址都存在自己的ARP表中，然后通过单播的方式向主机A发送ARP响应报文(其中包含自己的MAC地址)，主机A收到ARP响应报文中，将主机B的MAC地址加入到自己的ARP请求表中用于后续的报文转发，同时将IP数据包发送出去</p>
<h1 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h1><p>当浏览器从一个域名的网页去请求另一个域名的资源,协议,主机，端口号不同均为跨域</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/09/20/Rust%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/20/Rust%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">Rust基础入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-09-20 17:03:19" itemprop="dateCreated datePublished" datetime="2024-09-20T17:03:19+08:00">2024-09-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-09-24 11:39:57" itemprop="dateModified" datetime="2024-09-24T11:39:57+08:00">2024-09-24</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="变量绑定与解构"><a href="#变量绑定与解构" class="headerlink" title="变量绑定与解构"></a>变量绑定与解构</h1><h3 id="变量绑定"><a href="#变量绑定" class="headerlink" title="变量绑定"></a>变量绑定</h3><p>任何内存对象都是有主人的，而且一般情况下完全属于它的主人，绑定就是把这个对象绑定给一个变量，让这个变量成为它的主人-涉及所有权的概念</p>
<h3 id="变量可变性"><a href="#变量可变性" class="headerlink" title="变量可变性"></a>变量可变性</h3><p>Rust的变量在默认情况下是不可变的，可以通过 mut 关键字使变量变得可变。</p>
<h3 id="使用下划线开头忽略未使用的变量"><a href="#使用下划线开头忽略未使用的变量" class="headerlink" title="使用下划线开头忽略未使用的变量"></a>使用下划线开头忽略未使用的变量</h3><p>在变量开头添加下划线以忽略Rust对未使用的变量的警告</p>
<h3 id="变量解构"><a href="#变量解构" class="headerlink" title="变量解构"></a>变量解构</h3><p>let 表达式不仅用于变量的绑定，还可以用于复杂变量的解构：从一个相对复杂的变量中，匹配出该变量一部分内容</p>
<h4 id="解构式赋值"><a href="#解构式赋值" class="headerlink" title="解构式赋值"></a>解构式赋值</h4><p>可以在赋值语句的左式中使用元组，切片和结构等模式</p>
<h3 id="变量和常量之间的差异"><a href="#变量和常量之间的差异" class="headerlink" title="变量和常量之间的差异"></a>变量和常量之间的差异</h3><p>常量不允许使用使用mut。常量不仅默认是不可变的，且自始至终都是不可变的，当常量在编译完成后，就已经确定了它的值<br>常量使用const关键字而不是let关键字进行声明，并且值的类型必须进行标注</p>
<h3 id="变量遮蔽-shadowing"><a href="#变量遮蔽-shadowing" class="headerlink" title="变量遮蔽(shadowing)"></a>变量遮蔽(shadowing)</h3><p>Rust允许声明相同的变量名，在后面声明的变量会遮蔽掉前面的声明</p>
<h1 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h1><h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>Rust内置整数类型:类型定义的形式统一为:有无符号+类型大小。isize和usize取决于程序运行的计算机CPU类型，若CPU是32为的，则这两个类型都是32位的</p>
<h4 id="整型溢出"><a href="#整型溢出" class="headerlink" title="整型溢出"></a>整型溢出</h4><p>当在debug模式时，Rust会检查整型溢出，若存在该问题，程序在编译时panic。 当在release模式时，Rust会按照补码循环溢出的规则处理</p>
<h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p>在Rust中有两种浮点基本类型:f32和f64,默认浮点类型为f64，精度更高</p>
<h3 id="NAN"><a href="#NAN" class="headerlink" title="NAN"></a>NAN</h3><p>对于数学上未定义的结果，会产生一个特殊的结果NAN，Rust的浮点数使用NAN来处理这种情况<br>所有跟NAN交互的操作都会返回一个NAN，且NAN不能用来比较<br>可以使用is_nan()方法来判断一个值是否为NAN</p>
<h3 id="序列-Range"><a href="#序列-Range" class="headerlink" title="序列(Range)"></a>序列(Range)</h3><p>Rust使用序列来生成连续的值，例如:1..5生成1到4的连续数字,不包含5。1..&#x3D;5生成1到5的连续数字,包含5，常用于循环中</p>
<h3 id="使用As完成类型的转换"><a href="#使用As完成类型的转换" class="headerlink" title="使用As完成类型的转换"></a>使用As完成类型的转换</h3><p>Rust中使用As来完成一个类型到另一个类型的转换,其最常用于将原始类型转换为其他原始类型，也可以完成指针转换为地址，地址转换为指针等操作</p>
<h3 id="有理数和复数"><a href="#有理数和复数" class="headerlink" title="有理数和复数"></a>有理数和复数</h3><p>Rust数值库:num</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Rust拥有相当多的数字类型<br>类型转换必须是显示的<br>Rust在数值上可以使用方法</p>
<h2 id="字符、布尔、单元类型"><a href="#字符、布尔、单元类型" class="headerlink" title="字符、布尔、单元类型"></a>字符、布尔、单元类型</h2><h3 id="字符类型-char"><a href="#字符类型-char" class="headerlink" title="字符类型(char)"></a>字符类型(char)</h3><p>Rust的字符不仅仅是ASCII，所有的Unicode值都可以作为Rust字符，包括单个的中文，日文，韩文，emoji表情等</p>
<h3 id="布尔类型-bool"><a href="#布尔类型-bool" class="headerlink" title="布尔类型(bool)"></a>布尔类型(bool)</h3><p>Rust中的布尔类型有true和false两种，内存大小为1个字节</p>
<h3 id="单元类型"><a href="#单元类型" class="headerlink" title="单元类型"></a>单元类型</h3><p>单元类型就是(),fn main()中的返回类型就是()类型,fn main()函数并不是无返回值,因为无返回值的函数在Rust中是有单独定义的:发散函数(diverge function)<br>例如，可以使用()来作为Map中的值,表示我们不关心具体的值,只关心key,可以作为一个值来占位,但是完全不占用任何内存</p>
<h2 id="语句与表达式"><a href="#语句与表达式" class="headerlink" title="语句与表达式"></a>语句与表达式</h2><p>Rust的函数体是由一系列语句组成的，最后由一个表达式返回值</p>
<h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>语句没有返回值</p>
<h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>表达式会进行求值，最后返回一个值，末尾不能包含分号</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数要点"><a href="#函数要点" class="headerlink" title="函数要点"></a>函数要点</h3><p>函数名和变量名使用蛇形命名法，例如:fn add_two() -&gt; {}<br>函数的位置可以随便放,Rust不关心我们在哪里定义了函数，只要定义了即可<br>每个函数的参数都需要标注类型</p>
<h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>Rust是强类型语言，每一个函数参数都需要标注具体类型</p>
<h3 id="函数返回"><a href="#函数返回" class="headerlink" title="函数返回"></a>函数返回</h3><p>Rust的函数是表达式,我们可以把函数的返回值直接赋给调用者<br>函数的返回值是最后一条表达式，也可以使用return提前返回</p>
<h3 id="Rust中的特殊返回类型"><a href="#Rust中的特殊返回类型" class="headerlink" title="Rust中的特殊返回类型"></a>Rust中的特殊返回类型</h3><h4 id="无返回值"><a href="#无返回值" class="headerlink" title="无返回值()"></a>无返回值()</h4><p>单元类型()是一个零长度的元组，没啥作用，可以用来表达一个函数没有返回值</p>
<h4 id="永不返回的发散函数"><a href="#永不返回的发散函数" class="headerlink" title="永不返回的发散函数 !"></a>永不返回的发散函数 !</h4><p>当用 ! 作为函数的返回类型时，表示该函数永不返回，这种语法往往用作会导致程序崩溃的函数</p>
<h1 id="所有权和借用"><a href="#所有权和借用" class="headerlink" title="所有权和借用"></a>所有权和借用</h1><h2 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h2><p>三种流派:<br>垃圾回收机制(GC):在程序运行时不断寻找不再使用的内存，Java、Go<br>手动管理内存的分配和释放:在程序中，通过函数调用的方式来申请和释放内存，C++<br>通过所有权来管理内存:编译器在编译时根据一系列规则来检查</p>
<h3 id="所有权原则"><a href="#所有权原则" class="headerlink" title="所有权原则"></a>所有权原则</h3><p>1.Rust中每一个值都被一个变量所拥有，该变量被称为值的所有者<br>2.一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者<br>3.当所有者（变量）离开作用域范围时，这个值将被丢弃</p>
<h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><p>作用域是一个变量在程序中有效的范围</p>
<h3 id="变量绑定背后的数据交互"><a href="#变量绑定背后的数据交互" class="headerlink" title="变量绑定背后的数据交互"></a>变量绑定背后的数据交互</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x;</span><br></pre></td></tr></table></figure>
<p>这段代码并没有发生所有权的转移，代码首先将5绑定到变量x，接着拷贝x的值赋给y，最终x和y都等于5，因为整数是Rust中的基本数据类型，是固定大小的简单值，两个值都是通过自动拷贝的方式来赋值的，都被存放在栈中，无需在堆上分配内存</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br></pre></td></tr></table></figure>
<p>上面代码中的let s2 &#x3D; s1可以分两种情况讨论。<br>1.拷贝Stirng和存储在堆上的字节数组，如果该语句是拷贝所有数据（深拷贝），那么无论是String本身还是底层的堆数据，都会被全部拷贝，对于性能而言会造成很大影响<br>2.只拷贝String本身，这样的拷贝非常快，且当s1被赋予s2后，Rust认为s1不再有效，因此无需在s1离开作用域后drop任何东西，这就是把所有权从s1转移到s2,避免二次释放的错误导致内存污染</p>
<h4 id="克隆-深拷贝"><a href="#克隆-深拷贝" class="headerlink" title="克隆(深拷贝)"></a>克隆(深拷贝)</h4><p>Rust永远不会自动创建数据的深拷贝，任何自动的赋值都不属于深拷贝<br>当我们确实需要深度复刻String上堆中的数据，而不仅仅是栈上的数据，可以使用clone方法</p>
<h4 id="拷贝-浅拷贝"><a href="#拷贝-浅拷贝" class="headerlink" title="拷贝(浅拷贝)"></a>拷贝(浅拷贝)</h4><p>浅拷贝发生在栈上，性能很高<br>Rust中有一个叫做Copy的特征，可以用在类似整型这样在栈中存储的类型<br>任何基本类型的组合可以Copy,不需要分配内存或某种形式资源的类型可以Copy<br>例如：所有整数类型，布尔类型，所有浮点数类型，字符类型，元组（当且仅当包含的类型是可以Copy的），不可变引用&amp;T,可变引用&amp;mut T是不可以Copy的</p>
<h3 id="函数传值与返回"><a href="#函数传值与返回" class="headerlink" title="函数传值与返回"></a>函数传值与返回</h3><p>将值传递给函数，一样会发生移动或者复制</p>
<h2 id="引用与借用"><a href="#引用与借用" class="headerlink" title="引用与借用"></a>引用与借用</h2><p>Rust中可以通过借用(borrowing)来引用某个变量的指针或者引用</p>
<h3 id="引用与解引用"><a href="#引用与解引用" class="headerlink" title="引用与解引用"></a>引用与解引用</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> =<span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> =&amp;x;</span><br></pre></td></tr></table></figure>
<p>y是x的一个引用，可以通过*y来解出引用所指向的值（解引用）</p>
<h3 id="不可变引用"><a href="#不可变引用" class="headerlink" title="不可变引用"></a>不可变引用</h3><p>引用指向的值默认是不可变的</p>
<h3 id="可变引用"><a href="#可变引用" class="headerlink" title="可变引用"></a>可变引用</h3><p>首先，变量本身应该是可变的，才允许其引用是可变的，通过&amp;mut 来创建可变引用<br>可变引用同时只能存在一个<br>可变引用与不可变引用不能同时存在<br>引用作用域的结束位置是其最后一次使用的位置，旧版编译器是花括号位置</p>
<h3 id="NLL"><a href="#NLL" class="headerlink" title="NLL"></a>NLL</h3><p>专门用于找到某个引用在作用域{}结束前就不再被使用的代码位置</p>
<h3 id="悬垂引用"><a href="#悬垂引用" class="headerlink" title="悬垂引用"></a>悬垂引用</h3><p>指针指向某个值后，值被释放掉了，但是指针仍然存在，其指向的内存可能不存在任何值或者已经被其他变量重新使用<br>Rust中编译器确保引用永远不会变成悬垂状态</p>
<h3 id="借用规则总结"><a href="#借用规则总结" class="headerlink" title="借用规则总结"></a>借用规则总结</h3><p>同一时刻，要么拥有一个可变引用，要么拥有多个不可变引用<br>引用必须是有效的</p>
<h1 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h1><h2 id="字符串与切片"><a href="#字符串与切片" class="headerlink" title="字符串与切片"></a>字符串与切片</h2><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>切片是对String类型中某一部分的引用，切片的索引必须落在字符之间的边界位置（如中文字符会占用3个字节，此时如果只取两个字节就会报错）<br>其他集合类型也有切片，例如数组</p>
<h3 id="字符串字面量是切片"><a href="#字符串字面量是切片" class="headerlink" title="字符串字面量是切片"></a>字符串字面量是切片</h3><p>字符串字面量即&amp;s,他是一个不可变引用</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>Rust中的字符是Unicode类型的，因此每个字符占据4个字节内存空间<br>在字符串中，字符串是UTF-8编码的，也就是字符串中的字符所占的字节数是变化的(1-4)</p>
<h3 id="String和-str的转换"><a href="#String和-str的转换" class="headerlink" title="String和&amp;str的转换"></a>String和&amp;str的转换</h3><p>将&amp;str转换为String<br>1.String::from(&amp;str)<br>2.&amp;str.to_string()<br>将String转换为&amp;str只需要直接取引用即可(涉及到deref隐式强制转换)</p>
<h3 id="字符串索引"><a href="#字符串索引" class="headerlink" title="字符串索引"></a>字符串索引</h3><p>Rust中使用索引访问字符串会报错，Rust中String类型中的字符所占的字节数是变化的，Rust需要从0开始去遍历字符来定位合法的字符，这就无法保证索引操作的性能为O(1)</p>
<h3 id="操作字符串"><a href="#操作字符串" class="headerlink" title="操作字符串"></a>操作字符串</h3><p>String是可变字符串<br>追加(push):在原有字符串上追加，并不会返回新的字符串<br>push():追加字符char<br>push_str():追加字符串字面量</p>
<p>插入(insert):索引从0开始计数，如果越界则会发生错误<br>insert():插入字符,在指定位置插入字符<br>insert_str():插入字符串字面量,在指定位置插入字符串</p>
<p>替换(replace)<br>replace():适用于String和&amp;str,将字符串匹配到的字符串替换为目标字符串，该方法会返回一个新的字符串，而不是操作原来的字符串<br>replacen():作用于replace一致，传入第三个参数n表示需要替换的个数。该方法会返回一个新的字符串，而不是操作原来的字符串<br>replace_range():仅适用于String类型，接受两个参数，第一个表示替换字符串的范围，第二个表示新的字符串，该方法直接操作原来的字符串，不会返回新的字符串</p>
<p>删除(delete):仅适用于String类型，均是对原来的字符串进行操作<br>pop():删除并返回最后一个字符，返回值是一个Option类型<br>remove():删除并返回指定位置的字符，若参数所给的位置不是合法的字符边界，会报错<br>truncate():删除字符串中从指定位置开始到结尾的全部字符，无返回值，参数不合法会报错<br>clear():清空字符串</p>
<p>连接(concatenate)</p>
<ul>
<li>+&#x3D; :使用&#x3D;相当于调用了std:string标准库中的add()方法<br>format!() :适用于String和&amp;str</li>
</ul>
<h3 id="字符串转义"><a href="#字符串转义" class="headerlink" title="字符串转义"></a>字符串转义</h3><p>通过\输出ASCII字符<br>通过\u输出Unicode字符<br>使用\忽略换行符</p>
<h3 id="操作UTF-8字符串"><a href="#操作UTF-8字符串" class="headerlink" title="操作UTF-8字符串"></a>操作UTF-8字符串</h3><p>字符:使用chars方法<br>字节:使用bytes方法<br>获取子串:utf8_slice库</p>
<h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>元组是由多种类型组合到一起形成的，元组的长度是固定的，元组中元素的顺序也是固定的<br>可以使用模式匹配或者.来操作元组中的元素</p>
<h3 id="用模式匹配解构元组"><a href="#用模式匹配解构元组" class="headerlink" title="用模式匹配解构元组"></a>用模式匹配解构元组</h3><p>用同样形式的把一个复杂对象中的值匹配出来</p>
<h3 id="用-来访问元组"><a href="#用-来访问元组" class="headerlink" title="用.来访问元组"></a>用.来访问元组</h3><p>通过.来访问某个特定元素</p>
<h3 id="元组作为返回值"><a href="#元组作为返回值" class="headerlink" title="元组作为返回值"></a>元组作为返回值</h3><p>函数可以使用元组作为返回值来返回多个值</p>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h4><p>结构体组成:<br>通过关键字struct定义<br>结构体名称<br>结构体字段</p>
<h4 id="创建结构体实例"><a href="#创建结构体实例" class="headerlink" title="创建结构体实例"></a>创建结构体实例</h4><p>初始化时，每个字段都需要初始化<br>初始化时字段顺序不需要和结构体定义顺序一样</p>
<h4 id="访问结构体字段"><a href="#访问结构体字段" class="headerlink" title="访问结构体字段"></a>访问结构体字段</h4><p>必须将结构体实例定义为可变的才可以修改其中的字段<br>Rust不支持将某个结构体某个字段标记为可变</p>
<h3 id="结构体的内存排列"><a href="#结构体的内存排列" class="headerlink" title="结构体的内存排列"></a>结构体的内存排列</h3><p>把结构体中具有所有权的字段转移出去后，将无法再访问该字段，但是可以正常访问其他字段</p>
<h3 id="元组结构体"><a href="#元组结构体" class="headerlink" title="元组结构体"></a>元组结构体</h3><p>字段没有名称的结构体</p>
<h3 id="单元结构体"><a href="#单元结构体" class="headerlink" title="单元结构体"></a>单元结构体</h3><p>没有任何字段和属性的结构体<br>适用于某个类型，不关心他的内容，只关心他的行为</p>
<h3 id="结构体数据的所有权"><a href="#结构体数据的所有权" class="headerlink" title="结构体数据的所有权"></a>结构体数据的所有权</h3><p>在结构体上使用一个引用时，需要加上生命周期，否则会报错</p>
<h3 id="使用-derive-Debug-打印结构体信息"><a href="#使用-derive-Debug-打印结构体信息" class="headerlink" title="使用#[derive(Debug)]打印结构体信息"></a>使用#[derive(Debug)]打印结构体信息</h3><p>Rust默认不会为我们实现Debug，可以选择手动实现，或使用derive派生实现，<br>或使用dbg！宏，它会拿走表达式的所有权，然后打印出相应的文件名，行号等debug，除此之外，它最终还会把表达式值所有权返回</p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>枚举允许通过列举可能的成员来定义一个枚举类型</p>
<h3 id="同一化类型"><a href="#同一化类型" class="headerlink" title="同一化类型"></a>同一化类型</h3><h3 id="Option枚举用于处理空值"><a href="#Option枚举用于处理空值" class="headerlink" title="Option枚举用于处理空值"></a>Option枚举用于处理空值</h3><p>Option枚举包含两个成员，<br>Some<T>:，表示含有值，T是泛型参数，Some可以包含任何类型的数据<br>None:表示没有值<br>当一个值的类型不是Option<T>,就可以保证该值一定不为空<br>使用match表达式处理Option枚举</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>分为array和Vector两种<br>其中array是长度固定，元素必须有相同类型，依次线性排列的<br>而Vector是动态增长的</p>
<h3 id="数组元素为非基础类型"><a href="#数组元素为非基础类型" class="headerlink" title="数组元素为非基础类型"></a>数组元素为非基础类型</h3><p>调用std::array::form_fn实现数组初始化</p>
<h3 id="数组切片"><a href="#数组切片" class="headerlink" title="数组切片"></a>数组切片</h3><p>允许引用集合中的某一部分，而不是整个集合<br>切片的长度可以与数组不同，并不是固定的，取决于使用时的起始位置和结束位置<br>创建切片的代价非常小<br>切片类型[T]拥有不固定的大小，而&amp;[T]拥有固定大小，因此&amp;[T]更有用</p>
<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>for时我们往往使用集合的引用形式，否则集合的所有权会被转移到for语句中，后续无法继续使用该集合<br>如果希望在循环中对集合进行修改,可以使用mut关键字</p>
<p>对集合的引用进行for循环比通过索引访问更安全性能也更高，避免运行时边界检查</p>
<h1 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h1><h2 id="match和if-let"><a href="#match和if-let" class="headerlink" title="match和if let"></a>match和if let</h2><h3 id="match-匹配"><a href="#match-匹配" class="headerlink" title="match 匹配"></a>match 匹配</h3><p>在Rust中，模式匹配最常用的就是match和if let<br>match注意点:<br>1.match的匹配要穷举所有可能值，用_来代表未列出的所有可能性<br>2.match的每一个分支都必须是一个表达式，且所有分支的表达式最终返回值的类型必须相同<br>3.X|Y，类似逻辑运算符或，代表该分支既可以匹配X也可以匹配Y<br>match通用形式<br>match target{<br>    模式1 &#x3D;&gt; 表达式1,<br>    模式2 &#x3D;&gt; {<br>        语句1;<br>        语句2;<br>        表达式2<br>    },<br>    _ &#x3D;&gt; 表达式3,<br>}</p>
<h4 id="模式绑定"><a href="#模式绑定" class="headerlink" title="模式绑定"></a>模式绑定</h4><p>可以从模式中取出绑定的值</p>
<h4 id="穷尽匹配"><a href="#穷尽匹配" class="headerlink" title="穷尽匹配"></a>穷尽匹配</h4><p>match匹配必须穷尽所有情况</p>
<h4 id="通配符"><a href="#通配符" class="headerlink" title="_通配符"></a>_通配符</h4><p>通过特殊的模式_放置于其他分支后，_会匹配所有遗漏的值，()表示返回单元类型与所有分支返回值类型相同</p>
<h3 id="if-let匹配"><a href="#if-let匹配" class="headerlink" title="if let匹配"></a>if let匹配</h3><p>当只需要匹配一个条件，而其他条件可以忽略时，使用if let来替代match</p>
<h3 id="matches-宏"><a href="#matches-宏" class="headerlink" title="matches!宏"></a>matches!宏</h3><p>Rust标准库提供一个非常实用的宏:matches! 他可以将一个表达式跟模式进行匹配，然后返回匹配的结果true或false</p>
<h3 id="变量遮蔽"><a href="#变量遮蔽" class="headerlink" title="变量遮蔽"></a>变量遮蔽</h3><p>使用match和if let时，都是一个新代码块，如果使用同名变量，那么会发生变量遮蔽<br>match中的变量遮蔽是不明显的，最好不要使用同名避免难以理解</p>
<h2 id="解构Option"><a href="#解构Option" class="headerlink" title="解构Option"></a>解构Option</h2><p>一个变量要么有值Some(T),要么为空None</p>
<h3 id="匹配Option"><a href="#匹配Option" class="headerlink" title="匹配Option"></a>匹配Option</h3><p>使用Option<T>,是为了从Some中取出其内部的值T以及处理没有值的情况</p>
<h2 id="模式适用场景"><a href="#模式适用场景" class="headerlink" title="模式适用场景"></a>模式适用场景</h2><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>模式是Rust中的特殊语法，它用来匹配类型中的结构和类型，往往和match表达式联用，以实现强大的模式匹配能力<br>模式组成:<br>字面值<br>解构的数组、枚举、结构体、或者元组<br>变量<br>通配符<br>占位符</p>
<h4 id="所有可能用到模式的地方"><a href="#所有可能用到模式的地方" class="headerlink" title="所有可能用到模式的地方"></a>所有可能用到模式的地方</h4><h5 id="match分支"><a href="#match分支" class="headerlink" title="match分支"></a>match分支</h5><p>mathc的每个分支就是一个模式，因为match的匹配是穷尽的，因此我们需要一个特殊模式_来匹配剩余的所有情况</p>
<h5 id="if-let分支"><a href="#if-let分支" class="headerlink" title="if let分支"></a>if let分支</h5><p>if let往往用于匹配一个模式，而忽略剩下的所有模式场景</p>
<h5 id="while-let-条件循环"><a href="#while-let-条件循环" class="headerlink" title="while let 条件循环"></a>while let 条件循环</h5><p>只要模式匹配就可以一直进行while循环</p>
<h5 id="for循环-1"><a href="#for循环-1" class="headerlink" title="for循环"></a>for循环</h5><h5 id="let语句"><a href="#let语句" class="headerlink" title="let语句"></a>let语句</h5><p>let PATTERN &#x3D; EXPRESSION</p>
<h5 id="函数参数-1"><a href="#函数参数-1" class="headerlink" title="函数参数"></a>函数参数</h5><h2 id="全模式列表"><a href="#全模式列表" class="headerlink" title="全模式列表"></a>全模式列表</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/09/19/Quick-Start-for-Blog-Writing-MarkDown/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/19/Quick-Start-for-Blog-Writing-MarkDown/" class="post-title-link" itemprop="url">Quick Start for Blog Writing-MarkDown</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2024-09-19 16:43:53 / Modified: 17:13:50" itemprop="dateCreated datePublished" datetime="2024-09-19T16:43:53+08:00">2024-09-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-搭建github博客"><a href="#1-搭建github博客" class="headerlink" title="1. 搭建github博客"></a>1. 搭建github博客</h1><h2 id="1-1-确认github上创建的repository名称"><a href="#1-1-确认github上创建的repository名称" class="headerlink" title="1.1 确认github上创建的repository名称"></a>1.1 确认github上创建的repository名称</h2><h5 id="若在github上创建的名称为”repositoryName”-则在下一步中，本地创建的文件夹应该与github上创建的名称一致"><a href="#若在github上创建的名称为”repositoryName”-则在下一步中，本地创建的文件夹应该与github上创建的名称一致" class="headerlink" title="若在github上创建的名称为”repositoryName”,则在下一步中，本地创建的文件夹应该与github上创建的名称一致"></a>若在github上创建的名称为”repositoryName”,则在下一步中，本地创建的文件夹应该与github上创建的名称一致</h5><h2 id="1-2-用系统命令行安装hexo并初始化本地博客文件夹"><a href="#1-2-用系统命令行安装hexo并初始化本地博客文件夹" class="headerlink" title="1.2 用系统命令行安装hexo并初始化本地博客文件夹"></a>1.2 用系统命令行安装hexo并初始化本地博客文件夹</h2><h5 id=""><a href="#" class="headerlink" title=""></a></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-cli -g	<span class="comment"># 如果没有安装npm, 百度一下其他教程，这个不难，在此不赘述</span></span><br><span class="line">$ hexo init repositoryName  <span class="comment"># 注意这是我的博客名，你要替换成自己的，和github上创建的repo一模一样</span></span><br><span class="line">$ <span class="built_in">cd</span> repositoryName	<span class="comment"># 进入本地的博客文件夹（以下统称“本地博客文件夹”）</span></span><br><span class="line">$ npm install</span><br><span class="line">$ hexo server	<span class="comment"># 打开本地服务器预览</span></span><br></pre></td></tr></table></figure>
<p>查看是否有新安装的hexo主题博客<a target="_blank" rel="noopener" href="http://localhost:4000/">hexo本地查看</a></p>
<h2 id="1-3-下载并安装hexo-NexT主题"><a href="#1-3-下载并安装hexo-NexT主题" class="headerlink" title="1.3 下载并安装hexo NexT主题"></a>1.3 下载并安装hexo NexT主题</h2><h5 id="-1"><a href="#-1" class="headerlink" title=""></a></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-theme-next	<span class="comment"># 下载并安装NexT主题</span></span><br></pre></td></tr></table></figure>
<p>安装好后，打开本地博客文件夹下的config.yml文件,找到”theme”，修改成next<br>theme: next</p>
<h2 id="1-4-更新部署博客页面"><a href="#1-4-更新部署博客页面" class="headerlink" title="1.4 更新部署博客页面"></a>1.4 更新部署博客页面</h2><h5 id="-2"><a href="#-2" class="headerlink" title=""></a></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean	<span class="comment"># 清空一下缓存，有时候博客页面显示不正常也可以试试这个命令行</span></span><br><span class="line">$ hexo g	<span class="comment"># 是hexo generate的简写，把刚刚做的改动生成更新一下</span></span><br><span class="line">$ hexo server	<span class="comment"># 在本地服务器看看博客有没有更新成NexT主题：https://localhost:4000</span></span><br><span class="line">$ hexo d	<span class="comment"># hexo deploy，如果本地服务器看了没问题就可以输入github账号和密码传到网站上啦</span></span><br></pre></td></tr></table></figure>
<p>打开浏览器，输入网站名,<a target="_blank" rel="noopener" href="https://repositoryname/">https://repositoryName</a></p>
<h1 id="2-创建并发布自己的第一篇文章"><a href="#2-创建并发布自己的第一篇文章" class="headerlink" title="2. 创建并发布自己的第一篇文章"></a>2. 创建并发布自己的第一篇文章</h1><h2 id="2-1-用hexo-new-命令创建文章脚本"><a href="#2-1-用hexo-new-命令创建文章脚本" class="headerlink" title="2.1 用hexo new 命令创建文章脚本"></a>2.1 用hexo new 命令创建文章脚本</h2><h6 id="-3"><a href="#-3" class="headerlink" title=""></a></h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new post <span class="string">&quot;A Quick Start for Blog Writing-Markdown&quot;</span>	<span class="comment"># 这里引号里面是你的博客名称，这里我写的就是我第一篇博客的名称</span></span><br></pre></td></tr></table></figure>
<h2 id="2-2-编辑文章"><a href="#2-2-编辑文章" class="headerlink" title="2.2 编辑文章"></a>2.2 编辑文章</h2><h5 id="markdown-语法"><a href="#markdown-语法" class="headerlink" title="markdown 语法"></a><a target="_blank" rel="noopener" href="https://yuzehuiic.github.io/2021/05/29/A-Quick-Start-for-Blog-Writing-Markdown/">markdown 语法</a></h5><h2 id="2-3-发布文章-更新博客"><a href="#2-3-发布文章-更新博客" class="headerlink" title="2.3 发布文章&#x2F;更新博客"></a>2.3 发布文章&#x2F;更新博客</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo server	<span class="comment"># 先在本地预览一下，这一步也可以跳过，直接到下一步</span></span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Dabie_haze/article/details/117407833">原文链接</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/09/19/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/19/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-09-19 14:59:04" itemprop="dateCreated datePublished" datetime="2024-09-19T14:59:04+08:00">2024-09-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">John Doe</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
